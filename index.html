<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="WhenDo.IO : Modular Arduino-based teaching and prototyping tool.  Second Place at Greylock Hackfest.">

      <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link href="http://s3.amazonaws.com/codecademy-content/courses/ltp/css/shift.css" rel="stylesheet">
    <link rel="stylesheet" href="http://s3.amazonaws.com/codecademy-content/courses/ltp/css/bootstrap.css">

    <title>WhenDo.IO</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/agola11/WhenDo">View on GitHub</a>

          <h1 id="project_title">WhenDo.IO</h1>
          <h2 id="project_tagline">A modular, plug-and-play prototyping platform for Arduino.  The platform is also equipped with an intuitive visual programming language based on simple “When” and “Do” statements. Second place at Greylock Hackfest Summer 2014..</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/agola11/WhenDo/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/agola11/WhenDo/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h1>

<p>We built a system intended to provide a layer of abstraction on top of the Arduino micro-controller.  The system consists of a board containing slots to plug in modules.  This board connects to a laptop computer, which displays a browser-based UI. The user interacts with the system by plugging various sensor or actuator modules (servos, accelerometers, etc.). The system automatically detects new modules and displays them on the UI.  Once the interface is populated with modules, the user can link sensors and actuators together using “When” and “Do” statements, i.e. <b>“WHEN: Accelerometer detects left, DO: tilt servo to the left.”</b> </p>

<p>We originally intended for this system to be used as a teaching tool for beginner programmers, but we also believe that it can be used as a prototyping platform.  This system was built in 24 hours (we used every single second) during Greylock Hackfest, which is considered to be one of the most prestigious hackathons.  We were fortunate enough to win overall second place; our prizes inluded DJI Phantom Vision 2 quadcopters and accolades from several Silicon Valley execs including <a href="https://www.linkedin.com/in/poojasankar/">Pooja Sankar</a> of Piazza, <a href="https://www.linkedin.com/in/davidsze/">David Sze</a> from Greylock Partners, and <a href="https://www.linkedin.com/in/dpatil">DJ Patil</a>.</p>

<h2>People</h2>Ankush Gola, Joseph Bolling, Neil Chatterjee, Pranav Badami

<h1>Brief Technical Overview</h1>

<h2>Components</h2>
The system consists of the following components: a board with two Arduinos (one to detect modules, and one to interact with the modules), modules that plug into the board, and a laptop running a Django webserver and browser-based UI.  The polling Arduino on the board continuously detects newly plugged in modules and sends this information to the webserver.  The webserver saves information on the harddisk, then sends a packet to the client, where it is displayed on the UI.  The user interacts with the modules on the "WhenDo" prompt of the UI.  Once the user has picked a configeration, the UI sends this information back to the webserver, where it is translated in C++, then compiled into bytecode.  The bytecode is uploaded onto the logic arduino.  

<img src="images/WhenDoDiagram.png" >


<h2>Workflow</h2>

It is easiest to explain the system in more technical detail by breaking down the workflow.

<h3>Detecting Modules and Configurations</h3>

<p>
As you can see in the picture above, the board has two columns of rows consisting of a ground port, GPIO, and power (5V) port.  he GPIO ports on the board are connected to the <b>same number</b> serial ports on both Arduinos, and the power and ground ports on the board are connected to power and ground on <b>each</b> Arduino. </p>

<p>
We encased sensors and actuators in small cardboard boxes, exposing their power, ground, and I/O ports. We built three modules: a servo, push-button switch, and accelerometer. Each module also contains a resistor that is connected from I/O to ground on each sensor. The value of the resistor is different for each type of module.  The event of plugging in a module triggers an interrupt on the polling Arduino.  The polling Arduino knows the interrupt port, and figures out what module was plugged in by using the <code>analogRead</code> function and doing voltage divider arithmetic.  The Arduino sends the type of module and port in string format to a buffer read by the Django Webserver on the laptop over USB (this is done using the <code>pyserial</code> module). </p>


<img src="images/wd1.jpg" style="width: 480px; height: 271px;">

<img src="images/wd2.jpg" style="width: 480px; height: 271px;">

<h3>Updating the UI</h3>
<p>
The client continuously polls the webserver for new modules by hitting the <code>poll_from_serial</code> view in the Django server.  This view reads in new modules (and their ports) from the polling Arduino over the <code>pyserial</code> link.  The view creates either an <code>Accel</code>, <code>Servo</code>, or <code>Button</code> object encoded with the port number, then saves this object on the harddisk.  The object is serialized into JSON format, then sent to the browser client.  Each object also contains possible actions for each module (for example a <code>Servo</code> object can only tilt left/right.  These actions are actually the name of the C++ function that gets called once the "WhenDo" statements are compiled. More on this later. The UI leverages bootstrap, Angular, and JQuery to create the "WhenDo" prompt.  Once the user is satisfied with a configuration (i.e. "WHEN: Accelerometer detects left, DO: tilt servo to the left.”), the config gets serialized into a dictionary and sent back to the webserver. </p>

<img src="images/wd3.jpg" style="width: 480px; height: 271px;">

<h3>Compiling</h3>
To compile the "WhenDo" statements into valid Arduino code (C++), we created a <code>Compiler</code> class which recursively looks through "WhenDo" dictionary and rearranges it into C++ syntax. The dictionary can look something like this: <code> {"When":{{'accel':['port_1', 'port_3']}: 'is_left'}, "Do": {{'servo':'port_2'}: 'tilt_left'}}</code>

<p> This gets translated into something like this (exluding imports):
<code>

void setup(){
accel = Accel(1, 3)
servo = Servo(2)
}
void loop() {
 if (accel.isLeft()) { servo.tiltLeft() }
}
</code>

</p>

We wrote a C++ library to take care of the low-level Arduino interfacing (see <code>Blockduino.cpp</code>). This C++ gets compiled and uploaded onto the logic Arduino, and Ta-da!

<h2>More Info</h2>
Feel free to contact me with questions!

    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">WhenDo.IO maintained by <a href="https://github.com/agola11">agola11</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
